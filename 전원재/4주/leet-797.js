//문제에 대한 이해
// graph가 주어지고 0 부터 graph.length-1 만큼의 숫자가 주어집니다.
//그리고 0부터 마지막 숫자 까지 이어지는 연결의 경우의 수를 리턴해야 합니다.
// 연결은 순차적이며 중복은 없습니다.
// 만약 [[1,2,3], [2,3],[3,4],[4],[]] 이  주어지면
// [[0,1,2,4],[0,1,2,3,4],[0,1,3,4], [0,2,4], [0,2,3,4], [0,3,4]] 로 결과가 도출 될 수 있습니다(?)

var allPathsSourceTarget = function(graph) {
    let des = graph.length-1  // 목적지를 설정합니다.
 let result = []             // 결과를 빈배열로 만듭니다.
 let temp =[]               // 잠시 요소를 담을 배열을 만듭니다.
 const append = (num)=>{            //재귀를 위한 배열을 정의 합니다. num 인자는 0 부터 graph의 요소의 숫자들을 받습니다.
     temp.push(num)                 // 일시적인 배열에 num인자를 넣어줍니다. 0 부터 시작합니다.
     if(num === des){               // 만약 num 인자가 목적 숫자와 같다면 결과 값에 그 동안 모인 temp 요소를 넣어줍니다.
         result.push([...temp])     // 
     }
     const el = graph[num]     // el은 그래프의 num번째 배열을 가지고 옵니다. 
     for(let i=0; i<el.length; i++){ // 이때 num이 목적 숫자와 같다면 빈배열이므로 반복문은 작동하지 않습니다.
         append(el[i])          // 순차적으로 요소들을 재귀해줍니다.
                                // 만약 [1,2,3]을 차례로 넣어준다면 1 => [2,3]으로 가서 2 => [3,4] / 3 =>[4] 목적 숫자를 받아 
     }                      // 결과값에 넣어줍니다. 이처럼 반복되는 숫자들은 결국 목적 숫자에 도달하게 됩니다.
     
     temp.pop()   // num이 목적숫자기 때문에 반복문이 적용되지 않았다면 일시적으로 넣어준 temp의 마지막 숫자를 빼줍니다.  
 }                  // 이 과정은 중복을 막기 위한 것 입니다.
 append(0)
 
     return result
    
     
 };